#lang scheme

(require rnrs/mutable-pairs-6)

(define (make-node x prev next) (cons x (cons prev next)))
(define (data-node node) (car node))
(define (prev-node node) (cadr node))
(define (next-node node) (cddr node))
(define (set-prev! node prev) (set-car! (cdr node) prev))
(define (set-next! node next) (set-cdr! (cdr node) next))

(define (front-ptr dq) (car dq))
(define (rear-ptr dq) (cdr dq))
(define (set-front-ptr! dq x) (set-car! dq x))
(define (set-rear-ptr! dq x) (set-cdr! dq x))
(define (make-deque) (cons '() '()))

(define (empty-deque? dq) (null? (front-ptr dq)))
(define (front-deque dq)
  (if (empty-deque? dq)
      (error 'front-deque "called with an empty deque" dq)
      (data-node (front-ptr dq))))
(define (rear-deque dq)
  (if (empty-deque? dq)
      (error 'rear-deque "called with an empty deque" dq)
      (data-node (rear-ptr dq))))

(define (front-insert-deque! dq x)
  (cond ((empty-deque? dq)
         (let ((node (make-node x '() '())))
           (set-front-ptr! dq node)
           (set-rear-ptr! dq node)
           dq))
        (else
         (let* ((old-front (front-ptr dq))
                (new-front (make-node x '() old-front)))
           (set-prev! old-front new-front)
           (set-front-ptr! dq new-front)
           dq))))

(define (rear-insert-deque! dq x)
  (cond ((empty-deque? dq)
         (front-insert-deque! dq x))
        (else
         (let* ((old-rear (rear-ptr dq))
                (new-rear (make-node x old-rear '())))
           (set-next! old-rear new-rear)
           (set-rear-ptr! dq new-rear)
           dq))))

(define (front-delete-deque! dq)
  (cond ((empty-deque? dq)
         (error 'front-delete-deque! "called with an empty deque" dq))
        (else
         (let* ((old-front (front-ptr dq))
                (new-front (next-node old-front)))
           (cond ((null? new-front)
                  (set-front-ptr! dq '())
                  (set-rear-ptr! dq '())
                  dq)
                 (else (set-prev! new-front '())
                       (set-front-ptr! dq new-front)
                       dq))))))

(define (rear-delete-deque! dq)
  (cond ((empty-deque? dq)
         (error 'rear-delete-deque! "called with an empty deque" dq))
        (else
         (let* ((old-rear (rear-ptr dq))
                (new-rear (prev-node old-rear)))
           (cond ((null? new-rear)
                  (front-delete-deque! dq))
                 (else (set-next! new-rear '())
                       (set-rear-ptr! dq new-rear)
                       dq))))))

(define (print-deque dq)
  (define (iter node first)
    (when (not (null? node))
      (when (not first) (display ", "))
      (display (data-node node))
      (iter (next-node node) #f)))
  (display "[")
  (iter (front-ptr dq) #t)
  (display "]")
  (newline))

(define dq (make-deque))
(empty-deque? dq) 
(print-deque dq) 
(front-insert-deque! dq 'b)
(empty-deque? dq)
(rear-insert-deque! dq 'c)
(front-insert-deque! dq 'a)
(print-deque dq)
(rear-delete-deque! dq)
(print-deque dq) 
(front-delete-deque! dq)
(print-deque dq) 
(rear-delete-deque! dq)
(empty-deque? dq) 
(front-deque dq) 
(front-delete-deque! dq) 
(rear-delete-deque! dq) 